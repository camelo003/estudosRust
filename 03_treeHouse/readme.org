* tree_house

Exerc√≠cio do livro Hands-on Rust. Basicamente cria um fluxo de perguntas e respostas com ~println!()~ e ~read_line()~. A brincadeira √© que tem um seguran√ßa na porta de uma casa na √°rvore. Ele pergunta o nome de quem chega e, se for conhecido,deixa entrar com um cumprimento espec√≠fico para cada pessoa. Caso n√£o conhe√ßa, pergunta algumas informa√ß√µes e inclui o novo nome na lista. A seguir um gif com o programa rolando e um diagrama descrevendo o fluxo:

[[./cast1low.gif]]

[[./flowchart.svg]]

O c√≥digo est√° meio macarr√¥nico, mas for porque o exerc√≠cio foi adicionando elementos conforme ia avan√ßando, ao inv√©s de dar toda a especifica√ß√£o no in√≠cio. Mas vou comentando peda√ßo a peda√ßo na ordem e acho que d√° pra entender. O c√≥digo na √≠ntegra est√° em ~./tree_house/src/main.rs~.

#+NAME: main.rs
#+BEGIN_SRC rust -n
	use std::io::stdin;

	#[derive(Debug)]
	enum VisitorDiet {
			Meat,
			Oni,
			Vegan,
			Allergic {food: String},
	}

	#[derive(Debug)]
	struct Visitor {
			name: String,
			greeting: String,
			diet: VisitorDiet,
	}
#+END_SRC

Primeira coisa estranha de Rust: essas macros estranhas. Como d√° pra ver [[https://www.youtube.com/watch?v=MWRPYBoCEaY][nesse v√≠deo aqui]], macros em Rust podem ficar bem complicadas. Mas por ora me contentei com [[https://stackoverflow.com/questions/46388386/what-exactly-does-derivedebug-mean-in-rust][essa explica√ß√£o aqui]]. Basicamente esse tipo de macro, /derivativa/, antecedendo a defini√ß√£o de um enum ou struct, adiciona um c√≥digo na hora da compila√ß√£o que acrescenta funcionalidades para o respectivo enum ou struct. Nesse caso a capacidade de que eles possam ser 'printados' pela macro ~println!()~ quando utilizado o formatador de debug ~"{:?}"~. Precisei colocar essamacro quando passei a usar um vetor para guardar a lista (arrays tem tamanho fixo, mas vetores podem receber novos elementos).

No mais, essa primeira parte do c√≥digo √© uma defini√ß√£o bem comum de um struct e enum. Com um detalhe legal: enums em Rust podem ter seus pr√≥prios campos. Fiz com que a restri√ß√£o de dieta indicar uma alergia porque teria que guardar √† qual elemento a pessoa √© al√©rgica.  

#+NAME: main.rs
#+BEGIN_SRC rust -n
	impl Visitor {
			fn new(name: &str, greeting: &str, diet: VisitorDiet) -> Self {
					Self {
							name: name.to_lowercase(),
							greeting: greeting.to_lowercase(),
							diet,
					}
			}

			fn greet_visitor(&self) {
					println!("\n[SEGURAN√áA]\n{}", self.greeting);
					match &self.diet {
							VisitorDiet::Meat => println!("n√£o deixe de provar a picanha."),
							VisitorDiet::Oni => println!("pe√ßa uma carne com uma salada."),
							VisitorDiet::Vegan => println!("servimos leite de soja."),
							VisitorDiet::Allergic { food } => {
									println!("Vou pedir pra n√£o usarem {}.", food.trim());
							}
					}
			}
	}
#+END_SRC

Outra coisa que reparei: structs podem receber funcionalidade (m√©todos!). S√£o fun√ß√µes num segundo bloco ~impl~ que podem ou n√£o receber um refer√™ncia deumainst√¢ncia daquela estrutura. Ainda n√£o sei se √© assim que √© feita orienta√ß√£o a objetos em Rust, mas achei legal!

Nesse caso, a fun√ß√£o ~new()~ t√° fazendo o papel de /constructor/ (m√©todo est√°tico?) e a ~greet_visitor()~ faz uma sauda√ß√£o espec√≠fica pra cada nome que consta na lista e um coment√°rio sobre a dieta.

Mais um detalhe √© o block ~match~ que funciona como um ~switch-case~, mas cheio de macetes e uma sintaxe bem espec√≠fica. 

#+NAME: main.rs
#+BEGIN_SRC rust -n
	fn what_is_your_name() -> String {
			let mut your_name = String::new();
			println!("[VOC√ä]");
			stdin().read_line(&mut your_name).expect("\nerro ao ler resposta.\n");
			your_name.trim().to_lowercase()
	}

	fn first_came() -> Visitor {
			println!("\n[SEGURAN√áA]\nnunca te vi. qual √© o seu nome mesmo?");
			println!("\n[VOC√ä]");
			let mut new_name = String::new();
			stdin()
					.read_line(&mut new_name)
					.expect("erro ao ler resposta.");
			new_name = new_name.trim().to_lowercase();
			println!("\n[SEGURAN√áA]\ne como gostaria de ser recebido?");
			println!("\n[VOC√ä]");
			let mut new_greeting = String::new();
			stdin()
					.read_line(&mut new_greeting)
					.expect("erro ao ler resposta.");
			new_greeting = new_greeting.trim().to_lowercase();
			let mut diet_answer = String::new();
			let new_diet : VisitorDiet;
			loop {
					println!("\n[SEGURAN√áA]\npor √∫ltimo, como define sua dieta? responda com:");
					println!("[1] para carn√≠vora;");
					println!("[2] para on√≠vora;");
					println!("[3] para vegana;");
					println!("[4] se tiver alguma alergia.");
					println!("\n[VOC√ä]");
					stdin().read_line(&mut diet_answer).expect("erro ao ler resposta.");
					match diet_answer.trim() {
							"1" => {new_diet = VisitorDiet::Meat; break;},
							"2" => {new_diet = VisitorDiet::Oni; break;},
							"3" => {new_diet = VisitorDiet::Vegan; break;},
							"4" => {
									let mut new_food = String::new();
									println!("\n[SEGURAN√áA]\ntem alergia de que!?.");
									println!("\n[VOC√ä]");
									stdin().read_line(&mut new_food)
											.expect("erro ao ler resposta.");
									new_diet = VisitorDiet::Allergic{food: new_food};
									break;
							},
							_ => println!("\n[SEGURAN√áA]\nn√£o entendi."),
					}
			}
			println!("\n[SEGURAN√áA]\nobrigado! na pr√≥xima voc√™ pode entrar!");
			Visitor::new(&new_name, &new_greeting, new_diet)
	}
#+END_SRC

Essas duas fun√ß√µes avulsas s√£o para capturar o texto digitado pro nome da pessoa e pra fazer todoo processo de capturar as respostas pra registrar um novo nome na lista. A parte mais chata foi entender que strings literais escritas no proprio arquivo do c√≥digo fonte s√£o do tipo ~str~ e strings instanciadas com ~String::new()~ s√£o uma outra coisa. Esse bloco ~match~ que verifica a resposta sobre a dieta dos novos nomes foi super chato. O que entra logo depois do termo ~match~ e o que antecede cada setinha ~=>~ devem serdo mesmo tipo,o que faz sentido. Mas voc√™ tamb√©m n√£o pode executar uma fun√ß√£o antes das ~=>~, ent√£o n√£o sabia como fazer a compara√ß√£o. No fim o que resolveu foi o m√©todo ~.trim()~ na String recebia. Fora que o compilador reclama se n√£o houver um /"case default"/ (~_ =>~) ao fim do block ~match~, o que achei meio chato.

Mais uma coisa estranha: se voc√™ n√£o usa o m√©todo ~expect()~ o compilador fala que voc√™ tem que guardar o que volta de ~stdin().read_line()~ numa vari√°vel ü§® . 

#+NAME: main.rs
#+BEGIN_SRC rust -n
	fn main() {
			let mut name;
			let mut know_visitor;
			let mut visitors = vec![
					Visitor::new("gabriel",
											 "divirta-se, gabriel!",
											 VisitorDiet::Meat),
					Visitor::new("fernando",
											 "fernando, seu leite est√° na geladeira.",
											 VisitorDiet::Vegan),
					Visitor::new("marcos",
											 "marcos!? quem te convidou?",
											 VisitorDiet::Oni),
					Visitor::new("edu",
											 "fala, duds! hehe...",
											 VisitorDiet::Allergic {food: String::from("camar√£o")}),
					];

			loop {
					println!("[SEGURAN√áA]\nol√°! qual √© o seu nome? (vazio p/ encerrar)\n");
					name = what_is_your_name();
					know_visitor = visitors.iter().find(|visitor| visitor.name == name);

					match know_visitor {
							Some(visitor) => visitor.greet_visitor(),
							None => {
									if name.is_empty() {
											break;
									}else{
											visitors.push(first_came());
									}
							}
					}
					println!("\n----- ----- [PR√ìX. DA FILA] ----- -----\n");
			}
			println!("\nlista de convidados ao fim da noite:\n");
			println!("{:?}", visitors);
	}

#+END_SRC

Finalmente a fun√ß√£o ~main()~. Que nem em C, ela √© o ponto de entrada da execu√ß√£o do programa. Come√ßa preenchendo 4 valores iniciais no vetor com as pessoas conhecidas, s√≥ pra poder testar cada uma das 4 dietas, e continua com o loop que vai ficar perguntando o nome e respondendo de acordo.

Acho que a √∫nica surpresa aqui foi o uso do ~.iter()~ que me pareceu diferente de iteradores que j√° usei em Python ou Lua. Seguido por um ~.find()~ ele retorna uma /'option'/ (???) que precisa ser tratada nesse ~match~ ainda mais estranho que os outros.

No final, caso nenhum nome seja informado, ele ainda mostra o estado da lista. Ent√£o d√° rpa vercomo ficou o vetor.

E penso ser isso. Bastante conceito novo pra dar procurar sobre, mas t√¥ contando que eles v√£o voltar a aparecer mais pra frente no livro.

=]
