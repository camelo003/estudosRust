* flappy_dragon

Mais um exerc√≠cio do Hands-on Rust. Esse aqui usa a biblioteca [[https://github.com/amethyst/bracket-lib][bracket-lib]] que tem um monte de funcionalidade pra roguelike e emula um terminalzinho. O jogo √© um clone simples de Flappy Bird e foibem legal de fazer! Apesar de n√£o terfeito de forma linear, vou comentar /linearmente/ e focando nas partes interessantes de Rust.

[[./flappy.gif]]

A come√ßar pela forma de adicionar a biblioteca. Quando voc√™ cria um novo projeto com ~cargo new novo-projeto~ ela j√° cria um hello world numa estrutura de pastas bem conveniente e um arquivo ~Cargo.toml~ que vem assim:

#+BEGIN_SRC toml
[package]
name = "flappu_dragon"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]

#+END_SRC

Pra adicionar a biblioteca foi s√≥ acrescentar ~bracket-lib = "~0.8.1"~ em baixo de ~[dependencies]~ e pronto! Da pr√≥xima vez que compilar o seu programa com ~cargo run~ ele j√° baixa tudo que precisae deixa organizadinho nas patas do projeto. Bem legal, apesar de eu ter ficado surpreso com a quantidade de sub-depend√™ncias. Fora que pra algumas eu precisei baixar alguns pacotes promeu sistema operacional. tipo CMake que ainda n√£o tinha no meu computador.

Ali√°s, o pr√≥prio jeito de escrever a depend√™ncia no arquivo ~Cargo.toml~ representa algumas coisas. Por exemplo, o ~ em ~"~0.8.1"~ quer dizer que o gerenciador de depend√™ncias pode baixar uma vers√£o acima desde que sem quebras de compatibilidade com a 0.8.1; Algo pra [[https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html][estar atento]].

O autor do livro, Herbert Wolverson, chegou a publicar um artigo sobre o [[https://medium.com/pragmatic-programmers/flappy-dragon-rust-647e91a34dd4][projetinho desse exerc√≠cio]], ent√£o vou comentar minimamente minha vers√£o que est√° levemente diferente.

Como o projeto √© um jogo, vale a pena falar de algo que acho que √© pouco falado em tutoriais de programa√ß√£o pra jogos: a ideia de *m√°quina de estados finitos* (finite state machine em ingl√™s, as vezes abreviado pra FSM). Basicamente √© um jeito, muito √∫til, de descrever sistemas que podem assumir diferentes estados previstos, mas sempre um de cada vez; al√©m de todas as transi√ß√µes possiveis entre eles. Isso √© usado pra um monte de coisa. Por exemplo, o comportamento de um inimigo pode ser /andando/, /correndo/, ou /pulando/, mas ele s√≥ pode correr se estiver andando e s√≥ pode pular se estiver correndo.

Pra esse projetinho s√£o estados do pr√≥prio jogo: ~Menu~, para o menu inicial, ~Playing~, pra parte do jogo rolando e ~End~ pra tela de game over. Isso ajuda porque voc√™ pode separar o que precisa acontecer em cada +momento+ estado do jogo. As transi√ß√µes entre os estados tamb√©m √© algo importante de se ter claro. No caso, do menu inicial ser√° poss√≠vel ir pro jogo. Do jogo voc√™ pode ir pro game over (quando perder). E na tela de game over pode escolher jogar de novo ou sair. No gr√°fico d√° pra ver bem:

[[./states.png]]

Uma coisa que tenho notado sobre programar em Rust √© que √© /fortemente/ baseado em *structs*. Blocos ~struct~ e ~impl~ (fun√ß√µes de um ~struct~) parecem dar conta pelo menos do b√°sico de orienta√ß√£o √† objetos e estou achando isso √≥timo üòÖ. Aqui um diagrama de como ficaram as structs desse programinha:

[[./structs.png]]

Agora sim o c√≥digo comentado trecho a trecho:

#+BEGIN_SRC rust
use bracket_lib::prelude::*;
#+END_SRC

Ainda n√£o fiz nenhum programa dividido em mais de um um arquivo de c√≥digo fonte (fora depend√™ncias), mas j√° gostei do esquema de /namespaces/. Combinado com o padr√£o de expor somente o necess√°rio em um "prelude", fica f√°cil saber o que √© o que.

#+BEGIN_SRC rust
enum GameMode {
	Menu,
	Playing,
	End,
}
#+END_SRC

Aqui a defini√ß√£o do ~enum~ que vai guardar o estado em que o jogo se encontra.  

#+BEGIN_SRC rust
const SCREEN_WIDTH : i32 = 80;
const SCREEN_HEIGHT : i32 = 50;
const FRAME_DURATION : f32 = 1000.0 / 24.0;
#+END_SRC

Aqui umas constantes pra evitar espalhar n√∫meros m√°gicos pelo c√≥digo. A janela/terminal onde o jogo vai rodar ter√° um tamanho padr√£o de 80x50, mas mesmo assim vale registrar em constantes. E o pr√≥prio compilador sugere que se use CAIXA ALTA para constantes =] .

#+BEGIN_SRC rust
struct Player {
	x: i32,
	y: i32,
	velocity: f32,
}

impl Player {
	fn new(x: i32, y: i32) -> Self {
		Self {
			x,
			y,
			velocity: 0.0,
		}
	}
	fn render(&mut self, ctx: &mut BTerm) {
		if self.velocity < -1.0 {
			ctx.set(self.x - 1, self.y - 1, YELLOW, NAVY, to_cp437('_'));
			ctx.set(self.x - 2, self.y - 1, YELLOW, NAVY, to_cp437('_'));
		}else{
			ctx.set(self.x - 1, self.y - 2, YELLOW, NAVY, to_cp437('\\'));
			ctx.set(self.x, self.y - 1, YELLOW, NAVY, to_cp437('\\'));
		}
		ctx.set(self.x + 1, self.y - 1, YELLOW, NAVY, to_cp437('0'));
		ctx.set(self.x + 2, self.y - 1, YELLOW, NAVY, to_cp437('>'));
		ctx.set(self.x - 1, self.y, YELLOW, NAVY, to_cp437('/'));
		ctx.set(self.x, self.y, YELLOW, NAVY, to_cp437(')'));
		ctx.set(self.x - 1, self.y + 1, YELLOW, NAVY, to_cp437('"'));
		ctx.set(self.x - 2, self.y + 1, YELLOW, NAVY, to_cp437('"'));
	}
	fn gravity_and_move(&mut self) {
		if self.velocity < 2.0 {
			self.velocity += 0.2;
		}
		self.y += self.velocity as i32;
		self.x += 1;
		self.x = self.x % SCREEN_WIDTH;
		if self.y < 0 {
			self.y = 0;
		}
	}
	fn flap(&mut self) {
		self.velocity = -2.0;
	}
}
#+END_SRC

Struct e fun√ß√µes (m√©todos?) do player. Com os seguintes campos:

- ~x~, do tipo inteiro de 32 bit, para guardar  aposi√ß√£o horizontal do jogador;
- ~y~, tamb√©m inteiro 32, para a posi√ß√£o vertical;
- ~velocity~, um float de 32 bits, pra controlar o deslocamento vertical (gravidade e lufadas);

E os m√©todos:

- ~new()~, retorna um ~Player~ (dentro do bloco ~impl Player~ pode se escrever apenas ~Self~);
- ~render()~ pra desenhar / escrever o jogador na tela. Pra conseguir desenhar precisa receber uma refer√™ncia da "tela" ~BTerm~. Usei um monte de caractere pra deixar o passarinho bonitinho =] ;
- ~gravity_and_move()~ pra incrementar a posi√ß√£o horizontal de forma constante e linear (m√≥dulo pra mandar de volta ao come√ßo quando sair da tela) e alterando a posi√ß√£o vertical de acordo com o campo ~velocity~, al√©m de limitando a gravidade ;
- ~flap()~ altera o campo ~velocity~ pra 2.0, o que faz o passarinho dar um 'salto' pra cima.

#+BEGIN_SRC rust
struct Obstacle {
	x: i32,
	gap_y: i32,
	size: i32,
}

impl Obstacle {
	fn new (x: i32, score: i32) -> Self {
		let mut random = RandomNumberGenerator::new();
		Self {
			x,
			gap_y: random.range(10,40),
			size: i32::max(2, 20 - score),
		}
	}
	fn render (&self, ctx: &mut BTerm) {
		for y in 0..self.gap_y - self.size / 2 {
			ctx.print_color(self.x - 1, y, RED, NAVY, "###");
		}
		for y in (self.gap_y + self.size / 2)..SCREEN_HEIGHT {
			ctx.print_color(self.x - 1, y, RED, NAVY, "###");
		}
	}
	fn hit_obstacle (&self, player: &Player) -> bool {
		self.x == player.x && i32::abs(self.gap_y - player.y) > self.size/ 2
	}
}
#+END_SRC

Defini√ß√£o do "objeto" ~Obstacle~. Campos:

- ~x~, inteiro de 32 bits, posi√ß√£o horizontal do obst√°culo na tela;
- ~gap_y~, tamb√©m inteiro de 32, com a posi√ß√£o vertical da brecha no obst√°culo;
- ~size~, mesmo tipo, com a largura da brecha.

E os m√©todos:

- ~new()~, contructor, isso √©, cria um obst√°culo, retornando um pr√≥prio ~Obstacle~;
- ~render()~, pra desenhar o obst√°culo na tela;
- ~hit_osbstacle()~ recebe uma refer√™nciado jogador pra checar de ele colidiu com obst√°culo. Essa verifica√ß√£o ficou meio feia, linha muito comprida, mas dentro do meu limite (coluna 80, haha). Como n√£o precisa usar return em Rust, a √∫ltima express√£o de uma fun√ß√£o /sem/ o terminaldor ~;~. A linha ~self.x == player.x && i32::abs(self.gap_y - player.y) > self.size/ 2~ pode ser lida como /"se a posi√ß√£o horizontal do obst√°culo for a mesma do jogador E a diferen√ßa entre a posi√ß√£o vertical do jogador e a brecha do obst√°culon √© maior que metade da largura da brecha"/ (isso porque o valor ~gap_y~ marca o meio da brecha, ent√£o temos metade da largura pra cima e metade pra baixo). Reparem que pra pegar o valor absoluto (positivo) da diferen√ßa usei afun√ß√£o ~abs()~ que est√° no /namespace/ dotipo ~i32~, acessado com o operador ~::~ =] .

#+BEGIN_SRC rust
struct State {
	player: Player,
	frame_time: f32,
	mode: GameMode,
	score: i32,
	obstacles: Vec<Obstacle>,
}

impl State {
	fn new() -> Self {
		Self {
			player: Player::new(5, 25),
			frame_time: 0.0,
			mode: GameMode::Menu,
			score: 0,
			obstacles: vec![Obstacle::new(SCREEN_WIDTH / 2, 0)],
		}
	}
	fn play(&mut self, ctx: &mut BTerm) {
		ctx.cls_bg(NAVY);
		self.frame_time += ctx.frame_time_ms;
		if self.frame_time > FRAME_DURATION {
			self.frame_time = 0.0;
			self.player.gravity_and_move();
			if self.player.x == 0 {
				self.score+=1;
				self.place_obstacles();
			}
		}
		if let Some(VirtualKeyCode::Space) = ctx.key {
			self.player.flap();
		}
		for i in 0..self.obstacles.len() {
			self.obstacles[i].render(ctx);
		}
		self.player.render(ctx);
		ctx.print(0, 0,"Press SPACE: to fly.");
		ctx.print(0, 1,format!("Score: {}", self.score));
		for i in 0..self.obstacles.len() {
			if self.obstacles[i].x < self.player.x {
				continue;
			}
			if self.obstacles[i].hit_obstacle(&self.player) {
				self.mode = GameMode::End;
			}
		}
		if self.player.y > SCREEN_HEIGHT {
			self.mode = GameMode::End;
		}
	}
	fn restart(&mut self) {
		self.player = Player::new(5, 25);
		self.frame_time = 0.0;
		for _i in 0..self.obstacles.len() {
			self.obstacles.pop();
		}
		self.obstacles.push(Obstacle::new(SCREEN_WIDTH / 2, 0));
		self.score = 0;
		self.mode = GameMode::Playing;
	}
	fn main_menu(&mut self, ctx: &mut BTerm) {
		ctx.cls();
		ctx.print_centered(5, "Welcometo Flappy Dragon!");
		ctx.print_centered(8, "(P) Play Game");
		ctx.print_centered(9, "(Q) Quit Game");
		if let Some(key) = ctx.key {
			match key {
				VirtualKeyCode::P => self.restart(),
				VirtualKeyCode::Q => ctx.quitting = true,
				_ => {},
			}
		}
	}
	fn dead(&mut self, ctx: &mut BTerm) {
		ctx.cls();
		ctx.print_centered(5, "You are dead!");
		ctx.print_centered(8, format!("Your score: {}", self.score));
		ctx.print_centered(11, "(P) Play Game");
		ctx.print_centered(12, "(Q) Quit Game");
		if let Some(key) = ctx.key {
			match key {
				VirtualKeyCode::P => self.restart(),
				VirtualKeyCode::Q => ctx.quitting = true,
				_ => {},
			}
		}
	}
	fn place_obstacles(&mut self) {
		const CHANCES: [i32; 12] = [1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4];
		let mut random_gen = RandomNumberGenerator::new();
		let random_num: i32;
		let obstacles_num: i32;
		let interval: i32;

		for _i in 0..self.obstacles.len() {
			self.obstacles.pop();
		}
		random_num = random_gen.range(0, 12);
		obstacles_num = CHANCES[random_num as usize];
		interval = SCREEN_WIDTH / (obstacles_num + 1);
		for i in 1..=obstacles_num {
			self.obstacles.push(Obstacle::new(interval * i, self.score));
		}
	}
}
#+END_SRC

Finalmente, o struct que guarda o estado do jogo contendo:

- ~player~, uma inst√¢ncia do tipo ~Player~;
- ~frame_time~, um float de 32 bits pra contar o tempo e assim controlar o framerate do jogo;
- ~mode~, um enum ~GameMode~ pra guardar o estado atual do jogo,;
- ~score~, mais um inteiro de 32 bits (i32) pra guardar a pontua√ß√£o;
- ~obstacles~ um /vetor de ~Obstacle~/, pra abrigar diferentes quantidades de obst√°culos.

E os m√©todos:

- ~new()~, contructor, retorna um novo ~State~;
- ~play()~, o loop que controla o que acontece no jogo enquanto este estiver no estado ~GameMode::Playing~. Essa √© a maior fun√ß√£o porque nela est√° o loop que controla o cora√ß√£odojogo, ent√£o vale a pena descrever o que ela est√° fazendo. Basicamente:
  1. Limpa a tela com o m√©todo ~.cls_bg()~, nativo do objeto ~BTerm~, recebido comorefer√™ncia pela fun√ß√£o ~play()~ e proprio da biblioteca /bracket-lib/;
  2. Incrementa o valor do pr√≥prio campo ~frame_time~ com a difere√ßa de tempo entre o √∫ltimo loop e o atual, atrav√©s do campo ~.frame_time_ms~, tamb√©m do objeto ~BTerm~ recebido;
  3. Checa se o tempo transcorrido e acumulado no pr√≥prio campo ~frame_time~ √© maior do que a dura√ß√£o, em milisegundos, definida na constante ~FRAME_DURATION~. Isso garante que algumas coisas aconte√ßam apenas 24 vezes por segundo (influ√™ncia da gravidade no jogador, e checagem se o jogador atravessou a tela para incrementar a pontua√ß√£o e atualizar os obst√°culos, al√©m de zerar o tempo acumulado);
  4. Verifica se a tecla /espa√ßo/ foi apertada. Se sim, executa o m√©todo ~flap()~ do jogador. Aqui vale a pena falar sobre essa nota√ß√£o ~if let~:

  Pelo o que li, pra evitar ter o /nulo/ na linguagem, os designers de Rust decidiram por essa abordagem que achei muito legal. Coisas que podem ou n√£o conter algo retornam um ~enum~ chamado *Option*. Enum s√£o defini√ß√µes de um algo que pode ser apenas um de uma cole√ß√£o poss√≠veis. Tipo o ~GameMode~ que pode ser ~Menu~, ~Playing~, ou ~Playing~. No caso a defini√ß√£o do Option seria essa aqui:

#+BEGIN_SRC rust
enum Option<T> {
    None,
    Some(T),
}
#+END_SRC

  Em apenas 4 linhas tem bastante novidade, pelo menos pra mim. Essa √© a defini√ß√£o de um enum de nome ~Option~, igual outras defini√ß√µes de enums que vimos. ~<T>~ indica que esse enum lida com /tipos gen√©ricos/, isso √©, lida com mais de um tipo. Nenhuma surpresa em ~None~, √© s√≥ mais uma variante do enum. Agora o que √© ~Some(T)~? Em rust, cada variante pode conter data. No exercicio da casa da√°rvore cheguei a fazer um enum "Dieta" pra guardar o tipo de alimenta√ß√£o de cada membro do grupo. Esse enum tinha 4 variantes: carn√≠voro, on√≠voro, vegano ou al√©rgico. Para as tr√™s primeiras variantes, tudo certo. Mas pra /al√©rgico/ valia a pena que ela guardasse a informa√ß√£o /do qu√™/ aquele membro era al√©rgico. Variantes de enum podem guardar dados /nomeados/, como num struct (~Allergic {food: String}~), ou /n√£o-nomeados/ em algo que chamam de "tuple-struct". ~Some(T)~ √© um dado do /tipo gen√©rico T/ guardado dentro da variante /Some/.

  /E pra que tudo isso!?/ Como disse, pra fun√ß√µes onde coisas inesperadas podem acontecer a conven√ß√£o √© retornar uma /"op√ß√£o"/. Assim a linguagem Rustnos d√° v√°rias formas de trabalhar com essa op√ß√£o. Caso elatenha retornado /algo/ que est√°vamos esperando, ou n√£o tiver retornado /nada/: (~Some~ e ~None~).

  Pra acessar esse(s) dado(s) que /podem estar/ dentro de uma vari√°vel de um enum, √© poss√≠vel usar um bloco ~match~:

#+BEGIN_SRC rust
match opt {
	Some(x) => {
		// realmente tem algo nessa Option
		// fazer algo com 'x'
	}
	None => {
		// essa Option n√£o contem nada, mas o
		// programa n√£o precisa travar por isso
		// posso fazer algo a respeito nesse bloco
	}
}
#+END_SRC

  A nota√ß√£o ~if let~ pode funcionar como um bloco ~match~ abreviado. Seguida de uma atribui√ß√£o ~x = y~ ela executa o bloco seguinte */se/* y /desestruturar/ para x. D√° pra entender como uma checagem de padr√£o: se y est√° no mesmo padr√£o de x, execute o bloco a seguir. Na linha:

#+BEGIN_SRC rust
if let Some(VirtualKeyCode::Space) = ctx.key
#+END_SRC

  o que ele est√° checando √© /ctx.key √© uma variante ~Some~ com a tecla espa√ßo dentro?/ Se for o caso ele vai chamar a fun√ß√£o ~flappy()~. Lembrando que o campo ~.key~ e o valor ~Space~ dentro do /namespace/ ~VirtualKeyCode~ s√£o pr√≥prios da biblioteca bracket-lib. Se isso foimuito confuso (e provavelmente foi), vale a pena ler sobre [[https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html][enums]], [[https://doc.rust-lang.org/std/option/enum.Option.html][Option]], [[https://doc.rust-lang.org/rust-by-example/flow_control/if_let.html][if let]] e [[https://google.github.io/comprehensive-rust/tuples-and-arrays/destructuring.html][destructuring]].

  5. Desenha na tela /todos/ os obst√°culos, o jogador e escreve a pontua√ß√£o no canto da tela.
  6. Checagem pra ver se o jogador colidiu com algum obst√°culo, ou na parte de baixo da tela. Se sim, altera o estado do jogo pra ~End~.

- ~restart()~, √© a fun√ß√£o que reinicia os valores do jogo;
- ~main_menu()~, fun√ß√£o que roda em loop enquanto o jogo estiver no estado ~GameMode:Menu~. O que ela faz √© esperar pela a√ß√£o de iniciarou sair do jogo. Repare que o bloco ~if let~ captura a tecla (caso a checagem de padr√£o seja efetuada) e depois as op√ß√µes de entradas poss√≠veis s√£o feitas num bloco ~match~;
- ~dead()~, fun√ß√£o pra ser chamada em loop quando o jogo estiver no modo ~GameMode::End~. Tamb√©m aguarda entrada, dando op√ß√£o pro jogo reiniciar (voltar pro estado ~Playing~, ou sair);
- ~place_obstacles()~, essa fun√ß√£o zera e depois redistribui uma quantidade aleat√≥ria de obst√°culos. Pra fazer com que a chances de 1 ou 4 obst√°culos fossem menores que 2 ou 3, acabei fazendo uma gambiarra. Destribui uma s√©rie de 1's, 2's, 3's e 4's num array de 12 elementos, seguindo de acordo com a probabilidade que queria. Depois gerei um n√∫mero aleat√≥rio de 0 √† 11 e defini a quantidade de obst√°culos de acordo com o valor no √≠ndice do n√∫mero aleat√≥rio üò≥. N√£o me orgulho, mas resolveu (por favor me digam um jeito mais elegante de atingir o memso resultado).

#+BEGIN_SRC rust
impl GameState for State {
	fn tick (&mut self, ctx: &mut BTerm) {
		match self.mode {
			GameMode::Menu => self.main_menu(ctx),
			GameMode::End => self.dead(ctx),
			GameMode::Playing => self.play(ctx),
		}
	}
}
#+END_SRC

Aqui √© um exemplo simples de /trait/. Acho que ajuda a entender se traduzimos o nome pra /tra√ßo/ ou /caracter√≠stica/. N√£o vejo de orienta√ß√£o a objetos, mas acho que √© um forma de lidar com polimorfismo: fazer com que determinados structs possam ter determinados campo ou m√©todos definidos para que ent√£o possam ser utilizados em contextos em que se esperam tais campos/m√©todos.

Pode-se ler ~impl GameState for State~ como /segue implementa√ß√£o da caracter√≠stica ~GameState~ no struct ~State~/. A caracter√≠stica no caso √© uma fun√ß√£o ~tick()~ que recebe uma refer√™ncia mut√°vel da janela e associa os m√©todos ~main_menu()~, ~dead()~ e ~play()~ para serem chamadas em loop respectivamente durante os estados ~Menu~, ~End~ e ~Playing~

Os nomes ~GameState~ e ~tick~ s√£o esperados pela biblioteca em seu funcionamento interno.

#+BEGIN_SRC rust
fn main() -> BError {
	let context = BTermBuilder::simple80x50()
		.with_title("Flappy Dragon").
		build()?;
	main_loop(context, State::new())
}
#+END_SRC

Finalmente a fun√ß√£o ~main()~, ponto de entrada na execu√ß√£o do programa, faz apenas duas coisas:

1. Cria um /"contexto"/ onde o jogo vai acontecer,o que na pr√°tica √© uma janelinha emulando um terminal do tipo ~BTerm~.

2. Inicia o /game loop/, passando o contexto rec√©m criado e uma nova inst√¢ncia do 'objeto' ~State~.

Dois detalhes R√∫sticos (?): o primeiro √© que o contexto √© criado com uma sequ√™ncia de m√©todos (do namespace ~BTermBuilder~) encadeados que definem o tipo, tamanho e t√≠tulo de janela que ser√° criada e que finalmente √© criado com o m√©todo final ~.build()~. No livro fala que isso √© conhecido como [[https://refactoring.guru/design-patterns/builder/rust/example][/builder pattern/]] e √© algo comum em Rust.

O outro detalhe √© que a fun√ß√£o ~main()~ retorna algo do tipo ~BError~. Esse √© um tipo definido pela biblioteca bracket-lib. Ao /constuir/ o contexto/janela/terminal onde o jogo vai acontecer a biblioteca est√° trabalhando em baixo do cap√¥, pedindo pro sistema operacional os recursos necess√°rios pra que se possa fazer o que pretendemos fazer. Como isso √© algo que pode dar errado o padr√£o em Rust √© retornar um ~Result~. Parecido com ~Option~, ~Result~ √© um enum, desenhado pra que possamos tratar melhor eventuais erros. Um jeito de fazer isso seria um bloco ~match~. Tamb√©m seria poss√≠vel usar o m√©todo ~.unwrap()~ para acessar o que tiver dentro desse ~Result~. Mas se por acaso o que estivesse dentro fosse um erro o programa travaria (!!!). No caso, foi usado um terceiro tratamento poss√≠vel que √© colocar um ~?~ no final da fun√ß√£o que retorna o ~Result~. No caso de erro isso faz com que a fun√ß√£o onde fun√ß√£o que retorna o ~Result~ est√° sendo chamada (nesse caso a fun√ß√£o ~main()~) retorne o erro e por isso que ~main()~ precisa ser do tipo ~BError~, que √© o tipo de erro que viria dentro do ~Result~ retornado pelo ~BTermBuilder~ caso algo desse errado.

E para esse projeto √© isso =] . Ficou um pouco longo e talvez um pouco confuso, mas fico √† disposi√ß√£o para d√∫vidas ou qualquer outro tipo de pergunta.E claro,se notar algo /obscenamente/ errado, por favor avise üò± ! Obrigado!
